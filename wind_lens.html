<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Euler Fluid: 2 Ramp Diffuser ve Türbin Etkileşimli</title>
<style>
  body {
    font-family: verdana;
    font-size: 15px;
    margin: 0;
    overflow: hidden;
    user-select: none;
  }
  .button {
    background-color: #606060;
    border: none;
    color: white;
    padding: 10px 10px;
    font-size: 16px;
    margin: 4px 2px;
    cursor: pointer;
  }
  .slider {
    -webkit-appearance: none;
    width: 80px;
    height: 6px;
    border-radius: 5px;
    background: #d3d3d3;
    outline: none;
    opacity: 0.7;
    -webkit-transition: .2s;
    transition: opacity .2s;
  }
  #controls {
    padding: 8px;
    background: #eee;
    user-select: none;
  }
  #turbineSpeedValue {
    font-weight: bold;
    margin-left: 8px;
  }
  canvas {
    display: block;
    border: 2px solid #333;
  }
</style>
</head>

<body>

<div id="controls">
  <button class="button" onclick="resetObstaclePosition()">Reset Obstacle Position</button>
  <input type="checkbox" id="streamButton" onclick="scene.showStreamlines = !scene.showStreamlines" checked>Streamlines
  <input type="checkbox" id="velocityButton" onclick="scene.showVelocities = !scene.showVelocities">Velocities
  <input type="checkbox" id="pressureButton" onclick="scene.showPressure = !scene.showPressure;">Pressure
  <input type="checkbox" id="smokeButton" onclick="scene.showSmoke = !scene.showSmoke;" checked>Smoke
  <input type="checkbox" id="overrelaxButton" onclick="scene.overRelaxation = scene.overRelaxation == 1.0 ? 1.9 : 1.0" checked>Overrelax
  <label for="turbineSpeedSlider">Turbine Speed (rad/s):</label>
  <input type="range" id="turbineSpeedSlider" min="0" max="10" step="0.1" value="3" class="slider">
  <span id="turbineSpeedValue">3.0</span>
</div>

<canvas id="myCanvas"></canvas>

<script>
"use strict";

var canvas = document.getElementById("myCanvas");
var c = canvas.getContext("2d");

var simHeight = 1.15;
var cScale;

function resizeCanvas() {
  canvas.width = window.innerWidth + 900;
  canvas.height = window.innerHeight -100;
  cScale = canvas.height / simHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

function cX(x) {
  return x * cScale;
}
function cY(y) {
  return canvas.height - y * cScale;
}

// Constants to index vector fields
const U_FIELD = 0;
const V_FIELD = 1;
const S_FIELD = 2;

// Fluid simulation class
class Fluid {
  constructor(density, numX, numY, h) {
    this.density = density;
    this.numX = numX + 2; 
    this.numY = numY + 2;
    this.numCells = this.numX * this.numY;
    this.h = h;
    this.u = new Float32Array(this.numCells);
    this.v = new Float32Array(this.numCells);
    this.newU = new Float32Array(this.numCells);
    this.newV = new Float32Array(this.numCells);
    this.p = new Float32Array(this.numCells);
    this.s = new Float32Array(this.numCells);
    this.m = new Float32Array(this.numCells);
    this.newM = new Float32Array(this.numCells);
    this.m.fill(1.0);
  }

  integrate(dt, gravity) {
    var n = this.numY;
    for (var i = 1; i < this.numX; i++) {
      for (var j = 1; j < this.numY-1; j++) {
        if (this.s[i*n + j] != 0.0 && this.s[i*n + j-1] != 0.0)
          this.v[i*n + j] += gravity * dt;
      }
    }
  }

  solveIncompressibility(numIters, dt) {
    var n = this.numY;
    var cp = this.density * this.h / dt;
    for (var iter = 0; iter < numIters; iter++) {
      for (var i = 1; i < this.numX-1; i++) {
        for (var j = 1; j < this.numY-1; j++) {
          if (this.s[i*n + j] == 0.0)
            continue;

          var sx0 = this.s[(i-1)*n + j];
          var sx1 = this.s[(i+1)*n + j];
          var sy0 = this.s[i*n + j-1];
          var sy1 = this.s[i*n + j+1];
          var s = sx0 + sx1 + sy0 + sy1;
          if (s == 0.0)
            continue;

          var div = this.u[(i+1)*n + j] - this.u[i*n + j] + 
                    this.v[i*n + j+1] - this.v[i*n + j];
          var p = -div / s;
          p *= scene.overRelaxation;
          this.p[i*n + j] += cp * p;

          this.u[i*n + j] -= sx0 * p;
          this.u[(i+1)*n + j] += sx1 * p;
          this.v[i*n + j] -= sy0 * p;
          this.v[i*n + j+1] += sy1 * p;
        }
      }
    }
  }

  extrapolate() {
    var n = this.numY;
    for (var i = 0; i < this.numX; i++) {
      this.u[i*n + 0] = this.u[i*n + 1];
      this.u[i*n + this.numY-1] = this.u[i*n + this.numY-2]; 
    }
    for (var j = 0; j < this.numY; j++) {
      this.v[0*n + j] = this.v[1*n + j];
      this.v[(this.numX-1)*n + j] = this.v[(this.numX-2)*n + j];
    }
  }

  sampleField(x, y, field) {
    var n = this.numY;
    var h = this.h;
    var h1 = 1.0 / h;
    var h2 = 0.5 * h;

    x = Math.max(Math.min(x, this.numX * h), h);
    y = Math.max(Math.min(y, this.numY * h), h);

    var dx = 0.0;
    var dy = 0.0;

    var f;

    switch (field) {
      case U_FIELD: f = this.u; dy = h2; break;
      case V_FIELD: f = this.v; dx = h2; break;
      case S_FIELD: f = this.m; dx = h2; dy = h2; break;
    }

    var x0 = Math.min(Math.floor((x - dx)*h1), this.numX - 1);
    var tx = ((x - dx) - x0*h) * h1;
    var x1 = Math.min(x0 + 1, this.numX - 1);

    var y0 = Math.min(Math.floor((y - dy)*h1), this.numY - 1);
    var ty = ((y - dy) - y0*h) * h1;
    var y1 = Math.min(y0 + 1, this.numY - 1);

    var sx = 1.0 - tx;
    var sy = 1.0 - ty;

    var val = sx*sy * f[x0*n + y0] +
              tx*sy * f[x1*n + y0] +
              tx*ty * f[x1*n + y1] +
              sx*ty * f[x0*n + y1];

    return val;
  }

  avgU(i, j) {
    var n = this.numY;
    var u = (this.u[i*n + j-1] + this.u[i*n + j] +
             this.u[(i+1)*n + j-1] + this.u[(i+1)*n + j]) * 0.25;
    return u;
  }

  avgV(i, j) {
    var n = this.numY;
    var v = (this.v[(i-1)*n + j] + this.v[i*n + j] +
             this.v[(i-1)*n + j+1] + this.v[i*n + j+1]) * 0.25;
    return v;
  }

  advectVel(dt) {
    this.newU.set(this.u);
    this.newV.set(this.v);
    var n = this.numY;
    var h = this.h;
    var h2 = 0.5 * h;
    for (var i = 1; i < this.numX; i++) {
      for (var j = 1; j < this.numY; j++) {
        if (this.s[i*n + j] != 0.0 && this.s[(i-1)*n + j] != 0.0 && j < this.numY - 1) {
          var x = i*h;
          var y = j*h + h2;
          var u = this.u[i*n + j];
          var v = this.avgV(i, j);
          x = x - dt*u;
          y = y - dt*v;
          u = this.sampleField(x, y, U_FIELD);
          this.newU[i*n + j] = u;
        }
        if (this.s[i*n + j] != 0.0 && this.s[i*n + j-1] != 0.0 && i < this.numX - 1) {
          var x = i*h + h2;
          var y = j*h;
          var u = this.avgU(i, j);
          var v = this.v[i*n + j];
          x = x - dt*u;
          y = y - dt*v;
          v = this.sampleField(x, y, V_FIELD);
          this.newV[i*n + j] = v;
        }
      }
    }
    this.u.set(this.newU);
    this.v.set(this.newV);
  }

  advectSmoke(dt) {
    this.newM.set(this.m);
    var n = this.numY;
    var h = this.h;
    var h2 = 0.5 * h;
    for (var i = 1; i < this.numX-1; i++) {
      for (var j = 1; j < this.numY-1; j++) {
        if (this.s[i*n + j] != 0.0) {
          var u = (this.u[i*n + j] + this.u[(i+1)*n + j]) * 0.5;
          var v = (this.v[i*n + j] + this.v[i*n + j+1]) * 0.5;
          var x = i*h + h2 - dt*u;
          var y = j*h + h2 - dt*v;
          this.newM[i*n + j] = this.sampleField(x, y, S_FIELD);
        }
      }
    }
    this.m.set(this.newM);
  }

  simulate(dt, gravity, numIters) {
    this.integrate(dt, gravity);
    this.p.fill(0.0);
    this.solveIncompressibility(numIters, dt);
    this.extrapolate();
    this.advectVel(dt);
    this.advectSmoke(dt);
  }
}

// Scene & Fluid setup
var scene = {
  gravity : -9.81,
  dt : 1.0 / 120.0,
  numIters : 40,
  frameNr : 0,
  overRelaxation : 1.9,
  fluid: null,
  showStreamlines: true,
  showVelocities: false,
  showPressure: false,
  showSmoke: true,
  showObstacle: true,

  obstacleX1: 0.6,
  obstacleX2: 0.85,
  obstacleY1: 0.7,
  obstacleY2: 0.9,

  tabanUzunluk: 0.2,
  kalinlik: 0.02,
  rampaGenis: 0.03,
  rampaYuksel: 0.1,
  aralik: 0.7,

  turbineAngle: 0.22,
  turbineAngularSpeed: 10.0, // rad/s default
  turbineCenterX: 0.8,
  turbineCenterY: 0.57,
  turbineRadius: 0.25
};

// Diffuser poligonları oluşturma fonksiyonları
function buildLowerDiffuser(cx, cy){
  const y0 = cy - scene.kalinlik/2;
  const y1 = cy + scene.kalinlik/2;
  const xL = cx - scene.tabanUzunluk/2;
  const xR = cx + scene.tabanUzunluk/2;
  const xR0 = xR - scene.rampaGenis;
  const yTip = y1 + scene.rampaYuksel;
  return [
    [xL, y0],
    [xR, y0],
    [xR, yTip],
    [xR0, y1],
    [xL, y1],
  ];
}

function buildUpperDiffuser(cx, cy){
  const lowerPoly = buildLowerDiffuser(cx, 0);
  const flippedPoly = lowerPoly.map(p => [p[0], -p[1]]);
  const yShift = cy + scene.kalinlik - scene.aralik;
  return flippedPoly.map(p => [p[0], p[1] + yShift]);
}

// Çokgen içinde nokta testi
function pointInPolygon(point, polygon) {
  let x = point[0], y = point[1];
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    let xi = polygon[i][0], yi = polygon[i][1];
    let xj = polygon[j][0], yj = polygon[j][1];
    let intersect = ((yi > y) !== (yj > y)) &&
                    (x < (xj - xi) * (y - yi) / (yj - yi + 1e-12) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}

function setWindLensObstacles() {
  var f = scene.fluid;
  var n = f.numY;

  
  var lowerPoly = buildLowerDiffuser(scene.obstacleX2, scene.obstacleY2);
  var upperPoly = buildUpperDiffuser(scene.obstacleX2, scene.obstacleY2);

  for (var i = 1; i < f.numX - 1; i++) {
    for (var j = 1; j < f.numY - 1; j++) {
      var x = i * f.h;
      var y = j * f.h;
      f.s[i * n + j] = 1.0; // sıvı hücresi varsayılan

      if (
       
        pointInPolygon([x, y], upperPoly) ||
        pointInPolygon([x, y], lowerPoly)
      ) {
        f.s[i * n + j] = 0.0;   // katı hücresi
        f.u[i * n + j] = 0.0;
        f.v[i * n + j] = 0.0;
        f.m[i * n + j] = 1.0;
      }
    }
  }
}

// Obstacles çizimi
function drawObstacle() {
  if (!scene.showObstacle) return;

  c.lineWidth = 1.5;
  c.strokeStyle = "gray";
  c.fillStyle = "gray";

 

  let lowerPoly = buildLowerDiffuser(scene.obstacleX2, scene.obstacleY2);
  let upperPoly = buildUpperDiffuser(scene.obstacleX2, scene.obstacleY2);

  function drawPoly(poly) {
    c.beginPath();
    c.moveTo(cX(poly[0][0]), cY(poly[0][1]));
    for (let i = 1; i < poly.length; i++) {
      c.lineTo(cX(poly[i][0]), cY(poly[i][1]));
    }
    c.closePath();
    c.fill();
    c.stroke();
  }

  drawPoly(lowerPoly);
  drawPoly(upperPoly);
}

// Turbine blade drawing simulating YZ-plane rotation (rotation about X-axis)
function drawTurbine() {
  const blades = 5;  // 2 blades as you set
  const centerX = scene.turbineCenterX;
  const centerY = scene.turbineCenterY;
  const radius = scene.turbineRadius;

  c.lineWidth = 3;
  c.strokeStyle = "rgba(0, 0, 0, 0.2)";
  c.fillStyle = "rgba(0, 0, 0, 0.5)";

  for (let i = 0; i < blades; i++) {
    // Calculate phase of each blade (0 to 2π)
    let bladePhase = scene.turbineAngle + i * (2 * Math.PI / blades);

    // Since rotation is in YZ plane, project blade tip Y position as oscillation around centerY
    let tipY = centerY + radius * Math.cos(bladePhase);  // vertical tip position oscillates
    // Project blade tip Z (not visible) as sin(bladePhase), ignore for drawing

    // Base points slightly offset above and below centerY to form small blade width vertically
    let baseLeftY = centerY + 0.02;
    let baseRightY = centerY - 0.02;
    
    // Blade is like a vertical thin triangle pointing to tipY on Y axis, all at fixed centerX horizontally
    c.beginPath();
    c.moveTo(cX(centerX), cY(baseLeftY));
    c.lineTo(cX(centerX), cY(tipY));
    c.lineTo(cX(centerX), cY(baseRightY));
    c.closePath();
    c.fill();
    c.stroke();
  }

  // Draw center hub as a circle at turbine center position
  c.beginPath();
  c.fillStyle = "darkblue";
  c.arc(cX(centerX), cY(centerY), cScale * 0.015, 0, 2 * Math.PI);
  c.fill();
}

// Modify turbine flow effect to induce vertical velocities (v) only,
// simulating turbine rotation in YZ plane causing fluid pushing up/down near blades
function applyTurbineEffectToFlow() {
  let f = scene.fluid;
  let n = f.numY;
  let cx = scene.turbineCenterX;
  let cy = scene.turbineCenterY;
  let radius = scene.turbineRadius;
  let omega = scene.turbineAngularSpeed;

  for (let i = 1; i < f.numX - 1; i++) {
    for (let j = 1; j < f.numY - 1; j++) {
      let x = i * f.h;
      let y = j * f.h;

      let dx = x - cx;
      let dy = y - cy;
      let dist = Math.sqrt(dx*dx + dy*dy);

      if (dist < radius && dist > 0.15) {
        // Instead of tangential velocity (vx, vy), turbine rotation in YZ plane mainly adds vertical velocity
        // Approximate induced vertical velocity as sinusoidal in blade angular position around Y axis
        // Use position relative to center in Y direction to assign v velocity proportionally
        let verticalSpeed = omega * (1 - dist/radius);

        if (dy >= 0) {
          verticalSpeed = verticalSpeed;  // up direction
        } else {
          verticalSpeed = -verticalSpeed; // down direction
        }

        if (f.s[i*n + j] > 0) {
          // Add vertical velocity component
          f.v[i*n + j] = (f.v[i*n + j] + verticalSpeed) * 0.5;
          // Optionally reduce horizontal velocity impact
          f.u[i*n + j] = f.u[i*n + j] * 0.95; 
        }
      } else if (dist <= 0.005) {
        if (f.s[i*n + j] > 0) {
          f.u[i*n + j] = 0;
          f.v[i*n + j] = 0;
        }
      }
    }
  }
}

// Renk skalası fonksiyonu (Bilimsel renk skalası)
function getSciColor(val, minVal, maxVal) {
  val = Math.min(Math.max(val, minVal), maxVal - 0.0001);
  var d = maxVal - minVal;
  val = d == 0.0 ? 0.5 : (val - minVal) / d;
  var m = 0.25;
  var num = Math.floor(val / m);
  var s = (val - num * m) / m;
  var r, g, b;

  switch (num) {
    case 0 : r = 0.0; g = s; b = 1.0; break;
    case 1 : r = 0.0; g = 1.0; b = 1.0-s; break;
    case 2 : r = s; g = 1.0; b = 0.0; break;
    case 3 : r = 1.0; g = 1.0 - s; b = 0.0; break;
  }

  return [255*r,255*g,255*b, 255];
}

function draw() {
  c.clearRect(0, 0, canvas.width, canvas.height);

  var f = scene.fluid;
  var n = f.numY;

  var minP = f.p[0];
  var maxP = f.p[0];

  for (var i = 0; i < f.numCells; i++) {
    if (f.s[i] > 0) {
      minP = Math.min(minP, f.p[i]);
      maxP = Math.max(maxP, f.p[i]);
    }
  }

  var id = c.getImageData(0,0, canvas.width, canvas.height);

  var color = [255, 255, 255, 255];

  for (var i = 0; i < f.numX; i++) {
    for (var j = 0; j < f.numY; j++) {
      var idx = i*n + j;
      if (scene.showPressure && f.s[idx] > 0) {
        var p = f.p[idx];
        var s = f.m[idx];
        color = getSciColor(p, minP, maxP);
        if (scene.showSmoke) {
          color[0] = Math.max(0.0, color[0] - 255*s);
          color[1] = Math.max(0.0, color[1] - 255*s);
          color[2] = Math.max(0.0, color[2] - 255*s);
        }
      }
      else if (scene.showSmoke && f.s[idx] > 0) {
        var s = f.m[idx];
        color[0] = 255*s;
        color[1] = 255*s;
        color[2] = 255*s;
      }
      else if (f.s[idx] == 0.0) {
        color[0] = 0;
        color[1] = 0;
        color[2] = 0;
      }

      var x = Math.floor(cX(i * f.h));
      var y = Math.floor(cY((j+1) * f.h));
      var cx = Math.floor(cScale * 1.1 * f.h) + 1;
      var cy = Math.floor(cScale * 1.1 * f.h) + 1;

      var r = color[0];
      var g = color[1];
      var b = color[2];

      for (var yi = y; yi < y + cy; yi++) {
        var p = 4 * (yi * canvas.width + x);
        for (var xi = 0; xi < cx; xi++) {
          id.data[p++] = r;
          id.data[p++] = g;
          id.data[p++] = b;
          id.data[p++] = 255;
        }
      }
    }
  }

  c.putImageData(id, 0, 0);

  if (scene.showVelocities) {
    c.strokeStyle = "#000000";
    var scale = 0.02;

    for (var i = 0; i < f.numX; i++) {
      for (var j = 0; j < f.numY; j++) {
        var u = f.u[i*n + j];
        var v = f.v[i*n + j];

        c.beginPath();

        var x0 = cX(i * f.h);
        var x1 = cX(i * f.h + u * scale);
        var y = cY((j + 0.5) * f.h);

        c.moveTo(x0, y);
        c.lineTo(x1, y);
        c.stroke();

        var x = cX((i + 0.5) * f.h);
        var y0 = cY(j * f.h);
        var y1 = cY(j * f.h + v * scale);

        c.beginPath();
        c.moveTo(x, y0);
        c.lineTo(x, y1);
        c.stroke();
      }
    }
  }

  if (scene.showStreamlines) {
    var segLen = f.h * 0.2;
    var numSegs = 15;

    c.strokeStyle = "rgba(0,0,200, 0.1)";

    for (var i = 1; i < f.numX - 1; i += 5) {
      for (var j = 1; j < f.numY - 1; j += 5) {

        var x = (i + 0.5) * f.h;
        var y = (j + 0.5) * f.h;

        c.beginPath();
        c.moveTo(cX(x), cY(y));

        for (var n = 0; n < numSegs; n++) {
          var u = f.sampleField(x, y, U_FIELD);
          var v = f.sampleField(x, y, V_FIELD);
          var length = Math.sqrt(u*u + v*v);

          x += u * 0.01;
          y += v * 0.01;

          if (x > f.numX * f.h)
            break;

          c.lineTo(cX(x), cY(y));
        }
        c.stroke();
      }
    }
  }

  drawObstacle();
  drawTurbine();
}

// ----- Streamlines -----

var streamLines = [];
function createStreamlines() {
  streamLines = [];
  let f = scene.fluid;
  if (!f) return;
  let n = f.numY;
  let numStreamLines = 10;
  for (let i = 1; i < numStreamLines; i++) {
    let y = i * f.numY * f.h / numStreamLines;
    streamLines.push({x: 0.01, y: y});
  }
}

// Streamline çizim
function drawStreamlines(dt) {
  let f = scene.fluid;
  if (!f) return;

  for (let s of streamLines) {
    for (let i = 0; i < 20; i++) {
      let vx = f.sampleField(s.x, s.y, U_FIELD);
      let vy = f.sampleField(s.x, s.y, V_FIELD);
      s.x += vx * dt;
      s.y += vy * dt;

      if (s.x < 0) s.x = 0;
      if (s.x > f.numX * f.h) s.x = 0.01;
      if (s.y < 0) s.y = 0.01;
      if (s.y > f.numY * f.h) s.y = f.numY * f.h - 0.01;

      c.fillStyle = "rgba(200,200,255,0.1)";
      c.beginPath();
      c.arc(cX(s.x), cY(s.y), 1.5, 0, 2 * Math.PI);
      c.fill();
    }
  }
}

// Setup başlangıç sahnesi
function setupScene() {
  scene.dt = 1.0 / 60.0;
  scene.numIters = 40;

  var res = 100;
  var domainHeight = simHeight;
  var domainWidth = canvas.width / cScale;
  var h = domainHeight / res;

  var numX = Math.floor(domainWidth / h);
  var numY = Math.floor(domainHeight / h);

  var density = 1.225; // hava yoğunluğu kg/m³ varsayılan

  scene.fluid = new Fluid(density, numX, numY, h);

  var f = scene.fluid;
  var n = f.numY;

  // Kenarları katı yap, içi akışkan
  for (var i = 0; i < f.numX; i++) {
    for (var j = 0; j < f.numY; j++) {
      var s = 1.0;
      if (i == 0 || i == f.numX-1 || j == 0 || j == f.numY-1)
        s = 0.0;
      f.s[i*n + j] = s;
    }
  }

  // Engelleri yerleştir
  setWindLensObstacles();

  // Sol sınırda başlangıç hızı ve duman yoğunluğu
  for (var j = 1; j < f.numY - 1; j++) {
    var idx = 1 * f.numY + j;
    f.m[idx] = 1.0;
    f.u[idx] = 2.0;
  }

  scene.gravity = 0.0;

  createStreamlines();
}

// Döngü: simülasyon ve çizim
var lastTime = Date.now();

function loop() {
  let now = Date.now();
  let dtReal = (now - lastTime) * 0.001;
  lastTime = now;

  if (dtReal > 0.04) dtReal = 0.04;

  var f = scene.fluid;
  if (f) {
    // Sol sınır için hız sabit
    for (var j = 0; j < f.numY; j++) {
      var idx = 1 * f.numY + j;
      f.u[idx] = 2.0;
      f.v[idx] = 0;
    }

    // Türbin açısını güncelle
    scene.turbineAngle += scene.turbineAngularSpeed * dtReal;
    if (scene.turbineAngle > Math.PI * 2)
      scene.turbineAngle -= Math.PI * 2;

    // Türbinin akışkan üzerindeki dönme etkisini uygula
    applyTurbineEffectToFlow();

    // Akışkan simülasyonu adımı
    f.integrate(scene.dt, scene.gravity);
    f.solveIncompressibility(scene.numIters, scene.dt);
    f.extrapolate();
    f.advectVel(scene.dt);
    f.advectSmoke(scene.dt);
  }

  draw();

  if (scene.showStreamlines)
    drawStreamlines(scene.dt);

  requestAnimationFrame(loop);
}

// Reset butonu fonksiyonu: engeller ve türbin pozisyonu sıfırlansın
function resetObstaclePosition() {
  scene.obstacleX1 = 0.6;
  scene.obstacleX2 = 0.85;
  scene.obstacleY1 = 0.7;
  scene.obstacleY2 = 0.9;
  scene.turbineCenterX = 0.8;
  scene.turbineCenterY = 0.57;
  

  setWindLensObstacles();
}

// Slider olayları
var turbineSpeedSlider = document.getElementById('turbineSpeedSlider');
var turbineSpeedValue = document.getElementById('turbineSpeedValue');
scene.turbineAngularSpeed = parseFloat(turbineSpeedSlider.value);

turbineSpeedSlider.oninput = function () {
  scene.turbineAngularSpeed = parseFloat(this.value);
  turbineSpeedValue.textContent = this.value;
};

setupScene();
loop();


</script>

</body>
</html>
